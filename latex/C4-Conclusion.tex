%!TEX root = bambi-thesis.tex
The thesis provides \todo{Usare il passato ???} an implementation approach to \textit{georeference} and \textit{digitally encode} a geographic bounded area and to intelligently plan a \textit{coverage path} satisfying specific requirements. All this is achieved using \acrshort{ros} as software framework and therefore following at best its programming philosophy (i.e. modularity and distributive computing).\par
The main objective of the first part (\autoref{cha:georeferencing_the_mission_s_environment}), is to give basic knowledge regarding georeferentiation and to provide a way to acquire, store and manipulate the field border as geographic feature using the standard \acrfull{kml} format. Acquisition is done without particular difficulties thanks to Google Earth application and its graphical tools. At \acrshort{ros} sides it was required to write a simple Python node which, thanks to the \textsf{PyKML library}, parse the geographinc informations inside the \acrshort{kml} file and convert them to a ROS message. The implementation proves to work flawlessly without particular computational overhead even for big files. The outcome, an accurate and lightweight representation of the mission environment, is the base point of the entire mission and all other component lean on it.\par
The second part (\autoref{cha:coverage_path_planning}) is related to \acrfull{cpp}, thus generates the flight trajectory for the \acrshort{uav} in a way that, once completed, guarantees the total coverage of the target area by the on-board sensor. Several approaches from the literature were analyzed and at the end it is explain the algorithm implemented in the project. The proposal solution is based on \textit{wave-front} propagation algorithm that is largely used in navigation planning for mobile robot. For the required use case it was required to modify and rethink some parts of the original algorithm so to make it generate a \textit{coverage path}. Despite there are still space to further improvements, the results are satisfactory and the path well fits the physical properties of multirotor drones. Considering, in fact, the performance obtained in simulation environment(QUI FARE IL RIFERIMENTO AL CAP/SEC simulation results), it results that the algorithm is able to generate the trajectory for all the sample fields tested, proving to be quite robust.\\
Nevertheless, imperfections are still present, as the error caused by the approximate cellular decomposition which leads, in some situation, the trajectory to exceed the workplace boundary.
This drawback is intrinsic to the chosen area decomposition approach, but it was evaluated less important then the capability of relatively easy optimization for different path features (i.e. number of turns, terrain elevation, ecc.).\par

All the Bambi Project is available as opensource software, hosted at github under \url{https://github.com/BambiSaver}.
The project wiki is available at \url{https://wiki.bambi.florian.world} where some technical documentation and instructions on how to setup the workspace and build the code are provided.

\section{Future Works} % (fold)
\label{sec:future_work}
Many different adaptations, tests, and experiments have been left for the future due to lack of time (i.e. compile the code on the raspberry required $2$ hours). Future work concerns analysis of particular mechanisms, improvements, to try different methods and exhaustive on field testing.\par
Concerning the environment representation a great improvement could be to generate the orthophoto directly on the field. This would guarantee an up-to-dated image and eventually more accurate than Google Earth alternatives. A good starting point for this task could be to use \textsf{OpenDroneMap}, an open source toolkit for processing aerial drone imagery \cite{ODM}, which among other features provides the possibility to generate orthophoto. An important thing to evaluate is if the computing power of the Raspberry is enough to run this kind of images manipulation that is notoriously computationally expensive.\par
Another interesting feature, concerning image processing, would be to automatically detect the border of the field using a \textit{neural network}. This could be done through what is called \textit{semantic segmentation}\footnote{ Semantic segmentation describes the process of associating each pixel of an image with a class label (such as flower, person, road, sky, ocean, or car).}, thus to label every pixel of the target area as "field pixel". In this way the mission could be completely automated requiring almost no human interaction. Such kind of neural network would require a dataset of at least $1000$ images of different fields in order to be trained, therefore an huge amount of time as for each image the field must be manually recognized. After the training stage, the expected inference time on a Raspberry is around $300\, ms$ so perfectly feasible for the specific use case.\par
For the \acrfull{cpp}, the next step in the algorithm is to modify the cost function so that it takes care of the elevation profile provided by the already implemented \textsf{terrain\_data\_provider} node and to limit at maximum the number of turns. This requires to analyze and understand how to weight every features in order to build a coherent cost function. Once understand that, the only part that has to be changed in the \acrshort{cpp} algorithm is the wave-front propagation, i.e. where the matrix is filled according to the cost function (\autoref{cha:coverage_path_planning} \autoref{sub:wave_front_propagation_algorithm}).


\begin{itemize}
	\item Automatic field detection through IA image recognition
	\item improve CPP algorithm so that it takes care of elevation information and minimize turns/path length
	\item OTHER stuff
\end{itemize}
% section future_work (end)